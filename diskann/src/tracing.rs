/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 */

/// Line and file numbers generated by the `tracing::event!` family of macros use the
/// `file!()` and `line!()` macros.
///
/// Unfortunately, these do not respect `[track_caller]`, and so we lose some of the source
/// location tracking we currently rely on.
///
/// The `tracked_*` family of macros use `std::panic::Location::caller()` to correctly get
/// the caller and attach the info in "diskann.file" and "diskann.line".
///
/// Upstream handling should first look for these fields and only if they don't exist should
/// we inspect the file and line included as part of the tracing record.
#[cfg(feature = "tracing")]
#[macro_export]
macro_rules! tracked_error {
    ($($arg:tt)+) =>  {{
        let location = std::panic::Location::caller();
        ::tracing::error!(diskann.file = location.file(), diskann.line = location.line(), $($arg)+);
    }};
}

#[cfg(not(feature = "tracing"))]
#[macro_export]
macro_rules! tracked_error {
    ($($arg:tt)+) => {{
        $crate::used!($($arg)+);
    }};
}

#[cfg(feature = "tracing")]
#[macro_export]
macro_rules! tracked_warn {
    ($($arg:tt)+) => {{
        let location = std::panic::Location::caller();
        ::tracing::warn!(diskann.file = location.file(), diskann.line = location.line(), $($arg)+);
    }};
}

#[cfg(not(feature = "tracing"))]
#[macro_export]
macro_rules! tracked_warn {
    ($($arg:tt)+) => {{
        $crate::used!($($arg)+)
    }};
}

#[cfg(feature = "tracing")]
#[macro_export]
macro_rules! tracked_debug {
    ($($arg:tt)+) => {{
        let location = std::panic::Location::caller();
        ::tracing::debug!(diskann.file = location.file(), diskann.line = location.line(), $($arg)+);
    }};
}

#[cfg(not(feature = "tracing"))]
#[macro_export]
macro_rules! tracked_debug {
    ($($arg:tt)+) => {{
        $crate::used!($($arg)+);
    }};
}

#[cfg(feature = "tracing")]
#[macro_export]
macro_rules! tracked_trace {
    ($($arg:tt)+) => {{
        let location = std::panic::Location::caller();
        ::tracing::trace!(diskann.file = location.file(), diskann.line = location.line(), $($arg)+);
    }};
}

#[cfg(not(feature = "tracing"))]
#[macro_export]
macro_rules! tracked_trace {
    ($($arg:tt)+) => {{
        $crate::used!($($arg)+);
    }};
}

#[macro_export]
#[doc(hidden)]
macro_rules! used {
    ($($arg:tt)+) => {{
        // Using `format_args!` will:
        //
        // 1. Still validate the formatting is valid.
        // 2. Most likely compile away under optimizations.
        let _ = format_args!($($arg)+);
    }}
}
