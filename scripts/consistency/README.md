# Consistency / Precision Checks

This folder contains a lightweight consistency harness to quantify **bf16 precision loss** relative to float32 for DiskANN.

It runs the same dataset through:

- float32 **memory** index vs bf16 **memory** index
- float32 **disk** index vs bf16 **disk** index
- float32 **disk-PQ + reorder** vs bf16 **disk-PQ + reorder** (true bf16 reorder vectors on SSD)

and reports:

- Recall@K against float32 ground truth
- Top-1 ID match rate (bf16 vs float)
- Distance absolute error for IDs common to both outputs

## Quick start

```bash
# From repo root
bash scripts/consistency/run_consistency.sh
```

Artifacts are written to `scripts/consistency/_out` by default.

## What it runs

The harness generates a small float32 dataset, converts it to bf16 (round-to-nearest-even), then runs:

- **Memory**
  - float: `build_memory_index` + `search_memory_index`
  - bf16: `build_memory_index` + `search_memory_index`
- **Disk (full-precision)**
  - float: `build_disk_index` with `--PQ_disk_bytes 0` + `search_disk_index`
  - bf16: `build_disk_index` with `--PQ_disk_bytes 0` + `search_disk_index`
- **Disk (PQ + reorder)**
  - float: `build_disk_index --PQ_disk_bytes $DISK_PQ_BYTES --append_reorder_data` + `search_disk_index --use_reorder_data`
  - bf16: `build_disk_index --PQ_disk_bytes $DISK_PQ_BYTES --append_reorder_data` + `search_disk_index --use_reorder_data`

Ground truth is computed from the **float32** dataset using exact L2.

## How to run

### Default (recommended)

```bash
bash scripts/consistency/run_consistency.sh
```

### Custom size / speed knobs

Smaller + faster:

```bash
NPTS=2000 NQ=100 DIM=32 THREADS=4 bash scripts/consistency/run_consistency.sh
```

Bigger + more stable stats:

```bash
OUT_DIR=/tmp/diskann_consistency NPTS=20000 NQ=1000 DIM=128 K=10 MEM_L=100 DISK_L=100 bash scripts/consistency/run_consistency.sh
```

### Change disk-PQ compression

```bash
DISK_PQ_BYTES=16 bash scripts/consistency/run_consistency.sh
```

## Where outputs go

Inside `$OUT_DIR` (default: `scripts/consistency/_out`):

- `data/`
  - `base_f32.bin`, `query_f32.bin`
  - `base_bf16.bin`, `query_bf16.bin`
  - `gt_l2` (or `gt_l2.bin` depending on build) â€” the truthset file
- `results/`
  - Index prefixes (used by the apps):
    - `index_mem_f32*`, `index_mem_bf16*`
    - `index_disk_f32_full*`, `index_disk_bf16_full*`
    - `index_disk_f32_pq*`, `index_disk_bf16_pq*`
  - Search outputs (these are what the analyzer reads):
    - Memory: `mem_f32_${MEM_L}_idx_uint32.bin`, `mem_f32_${MEM_L}_dists_float.bin` and bf16 equivalents
    - Disk: `disk_*_${DISK_L}_idx_uint32.bin`, `disk_*_${DISK_L}_dists_float.bin`

## How to read the results

At the end, the runner calls `scripts/consistency/analyze_results.py` and prints three blocks:

- `== Memory ==`
- `== Disk (full-precision) ==`
- `== Disk (PQ + reorder) ==`

Each block reports:

- **Recall@K (float vs bf16)**
  - Computed against the float32 ground truth (exact L2).
  - The `delta` shows how much recall changes when switching to bf16.

- **Top1 ID match rate (bf16 vs float)**
  - For each query, whether the #1 result ID matches between bf16 and float outputs.
  - Useful when Recall@K is similar but top-1 stability differs.

- **Distance abs error on common IDs (mean / p99 / max)**
  - Per query, only considers IDs that appear in *both* top-K lists (to avoid comparing unrelated candidates).
  - Measures absolute distance differences between bf16 and float results.
  - For normalized vectors, these values are usually small; if they get large, it may indicate bf16 quantization loss
    (or a bug in bf16 IO / distance kernels).

## Tuning (env vars)

- `OUT_DIR` (default: `scripts/consistency/_out`)
- `NPTS` (default: 5000), `NQ` (default: 200), `DIM` (default: 64)
- `K` (default: 10)
- `MEM_L` (default: 50), `DISK_L` (default: 50)
- `THREADS` (default: 4)
- Disk build/search knobs:
  - `DISK_R` (default: 16)
  - `DISK_LBUILD` (default: 50)
  - `DISK_PQ_BYTES` (default: 8)

## Notes / assumptions

- This harness currently uses **L2** to isolate precision effects; cosine/mips can be added similarly if needed.
- The bf16 dataset is generated by converting the float32 dataset, so any differences should come from bf16 rounding
  and bf16 compute paths (not from a different random dataset).
